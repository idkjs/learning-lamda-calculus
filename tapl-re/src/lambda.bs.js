// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Result$ReasonLambdas = require("./result.bs.js");

function ty_unit(param) {
  return /* Ty_unit */0;
}

function ty_lam(lhs, rhs) {
  return {
          TAG: /* Ty_lam */0,
          _0: lhs,
          _1: rhs
        };
}

function ty_named(name) {
  return {
          TAG: /* Ty_named */1,
          _0: name
        };
}

function unit(param) {
  return /* Term_unit */1;
}

function marker(param) {
  return /* Term_marker */0;
}

function $$var(name) {
  return {
          TAG: /* Term_var */0,
          _0: name
        };
}

function abs(ty, name, body) {
  return {
          TAG: /* Term_abs */1,
          _0: ty,
          _1: name,
          _2: body
        };
}

function app(callee, parm) {
  return {
          TAG: /* Term_app */2,
          _0: callee,
          _1: parm
        };
}

function let_in(name, init, body) {
  return {
          TAG: /* Term_let_in */3,
          _0: name,
          _1: init,
          _2: body
        };
}

function type_in(name, ty, body) {
  return {
          TAG: /* Term_type_in */4,
          _0: name,
          _1: ty,
          _2: body
        };
}

function string_of_ty(ty) {
  var is_cmplx = function (ty) {
    if (typeof ty === "number" || ty.TAG) {
      return true;
    } else {
      return false;
    }
  };
  if (typeof ty === "number") {
    return "unit";
  }
  if (ty.TAG) {
    return ty._0;
  }
  var lhs = ty._0;
  var lhs$prime = is_cmplx(lhs) ? "(" + (string_of_ty(lhs) + ") -> ") : string_of_ty(lhs) + " -> ";
  return lhs$prime + string_of_ty(ty._1);
}

function print_ty(ty) {
  return Pervasives.print_string(string_of_ty(ty));
}

function print_term(_term) {
  while(true) {
    var term = _term;
    var is_cmplx = function (param) {
      if (typeof param === "number" || !param.TAG) {
        return false;
      } else {
        return true;
      }
    };
    var print_cmplx = function (tm) {
      if (is_cmplx(tm)) {
        Pervasives.print_char(/* "(" */40);
        print_term(tm);
        return Pervasives.print_char(/* ")" */41);
      } else {
        return print_term(tm);
      }
    };
    if (typeof term === "number") {
      if (term === /* Term_marker */0) {
        return Pervasives.print_char(/* "@" */64);
      } else {
        return Pervasives.print_string("()");
      }
    }
    switch (term.TAG | 0) {
      case /* Term_var */0 :
          return Pervasives.print_string(term._0);
      case /* Term_abs */1 :
          var $$var = term._1;
          Pervasives.print_char(/* "/" */47);
          if ($$var !== undefined) {
            Pervasives.print_string($$var);
          } else {
            Pervasives.print_char(/* "_" */95);
          }
          Pervasives.print_char(/* ":" */58);
          print_ty(term._0);
          Pervasives.print_char(/* "." */46);
          _term = term._2;
          continue ;
      case /* Term_app */2 :
          print_cmplx(term._0);
          Pervasives.print_char(/* " " */32);
          return print_cmplx(term._1);
      case /* Term_let_in */3 :
          Pervasives.print_string("let " + (term._0 + " = "));
          print_cmplx(term._1);
          Pervasives.print_string(" in\n");
          return print_cmplx(term._2);
      case /* Term_type_in */4 :
          Pervasives.print_string("type " + (term._0 + " = "));
          print_ty(term._1);
          Pervasives.print_string(" in\n");
          return print_cmplx(term._2);
      
    }
  };
}

function string_of_ast(ast) {
  var is_cmplx = function (ast) {
    if (typeof ast === "number") {
      return false;
    }
    switch (ast.TAG | 0) {
      case /* Ast_abs */1 :
      case /* Ast_app */2 :
          return true;
      default:
        return false;
    }
  };
  var soa_rec = function (ast, names) {
    var soa_cmplx = function (ast) {
      if (is_cmplx(ast)) {
        return "(" + (soa_rec(ast, names) + ")");
      } else {
        return soa_rec(ast, names);
      }
    };
    if (typeof ast === "number") {
      if (ast === /* Ast_marker */0) {
        return "@";
      } else {
        return "()";
      }
    }
    switch (ast.TAG | 0) {
      case /* Ast_var */0 :
          var _idx = ast._0;
          var _names = names;
          while(true) {
            var names$1 = _names;
            var idx = _idx;
            if (!names$1) {
              return Pervasives.failwith("malformed lambda calculus ast");
            }
            var name = names$1.hd;
            if (idx === 0) {
              if (name !== undefined) {
                return Caml_option.valFromOption(name);
              } else {
                return Pervasives.failwith("malformed lambda calculus ast");
              }
            }
            _names = names$1.tl;
            _idx = idx - 1 | 0;
            continue ;
          };
      case /* Ast_abs */1 :
          var name$1 = ast._1;
          var name$prime = name$1 !== undefined ? name$1 : "_";
          return "/" + (name$prime + (":" + (string_of_ty(ast._0) + ("." + soa_rec(ast._2, {
                              hd: name$1,
                              tl: names
                            })))));
      case /* Ast_app */2 :
          return soa_cmplx(ast._0) + (" " + soa_cmplx(ast._1));
      
    }
  };
  return soa_rec(ast, /* [] */0);
}

function print_ast(ast) {
  return Pervasives.print_string(string_of_ast(ast));
}

function print_type_error(err) {
  switch (err.TAG | 0) {
    case /* Type_error_variable_not_found */0 :
        return Pervasives.print_string("variable not found: " + err._0);
    case /* Type_error_type_not_found */1 :
        return Pervasives.print_string("type not found: " + err._0);
    case /* Type_error_incorrect_types */2 :
        return Pervasives.print_string("type mismatch: " + (string_of_ty(err._0) + (" != " + string_of_ty(err._1))));
    case /* Type_error_calling_non_callable */3 :
        return Pervasives.print_string("attempt to call non-callable: " + (string_of_ty(err._0) + ("\n  " + string_of_ast(err._1))));
    
  }
}

function typeof_rec(ast, tys) {
  if (typeof ast === "number") {
    if (ast === /* Ast_marker */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                TAG: /* Ty_lam */0,
                _0: /* Ty_unit */0,
                _1: /* Ty_unit */0
              }
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: /* Ty_unit */0
            };
    }
  }
  switch (ast.TAG | 0) {
    case /* Ast_var */0 :
        return {
                TAG: /* Ok */0,
                _0: List.nth(tys, ast._0)
              };
    case /* Ast_abs */1 :
        var ty = ast._0;
        return Result$ReasonLambdas.Monad.$great$great$eq(typeof_rec(ast._2, {
                        hd: ty,
                        tl: tys
                      }), (function (it) {
                      return Result$ReasonLambdas.Monad.pure({
                                  TAG: /* Ty_lam */0,
                                  _0: ty,
                                  _1: it
                                });
                    }));
    case /* Ast_app */2 :
        var ty$1 = typeof_rec(ast._0, tys);
        if (ty$1.TAG) {
          return {
                  TAG: /* Err */1,
                  _0: ty$1._0
                };
        }
        var ty$2 = ty$1._0;
        if (typeof ty$2 === "number") {
          return {
                  TAG: /* Err */1,
                  _0: {
                    TAG: /* Type_error_calling_non_callable */3,
                    _0: ty$2,
                    _1: ast
                  }
                };
        } else if (ty$2.TAG) {
          return Pervasives.failwith("malformed ast");
        } else {
          return {
                  TAG: /* Ok */0,
                  _0: ty$2._1
                };
        }
    
  }
}

function $$typeof(ast) {
  var ty = typeof_rec(ast, /* [] */0);
  if (ty.TAG) {
    return Pervasives.failwith("malformed ast");
  }
  var ty$1 = ty._0;
  if (typeof ty$1 === "number" || !ty$1.TAG) {
    return ty$1;
  } else {
    return Pervasives.failwith("malformed ast");
  }
}

function finish(tm) {
  var get_structural_ty = function (ty, ty_names) {
    if (typeof ty === "number") {
      return Result$ReasonLambdas.Monad.pure(/* Ty_unit */0);
    }
    if (ty.TAG) {
      var name = ty._0;
      var _ty_names = ty_names;
      while(true) {
        var ty_names$1 = _ty_names;
        if (!ty_names$1) {
          return {
                  TAG: /* Err */1,
                  _0: {
                    TAG: /* Type_error_type_not_found */1,
                    _0: name
                  }
                };
        }
        var match = ty_names$1.hd;
        if (match[0] === name) {
          return {
                  TAG: /* Ok */0,
                  _0: match[1]
                };
        }
        _ty_names = ty_names$1.tl;
        continue ;
      };
    }
    var rhs = ty._1;
    return Result$ReasonLambdas.Monad.$great$great$eq(get_structural_ty(ty._0, ty_names), (function (lhs) {
                  return Result$ReasonLambdas.Monad.$great$great$eq(get_structural_ty(rhs, ty_names), (function (rhs) {
                                return Result$ReasonLambdas.Monad.pure({
                                            TAG: /* Ty_lam */0,
                                            _0: lhs,
                                            _1: rhs
                                          });
                              }));
                }));
  };
  var finish_rec = function (tm, names, tys, ty_names) {
    if (typeof tm === "number") {
      if (tm === /* Term_marker */0) {
        return {
                TAG: /* Ok */0,
                _0: /* Ast_marker */0
              };
      } else {
        return {
                TAG: /* Ok */0,
                _0: /* Ast_unit */1
              };
      }
    }
    switch (tm.TAG | 0) {
      case /* Term_var */0 :
          var name = tm._0;
          var _names = names;
          var _idx = 0;
          while(true) {
            var idx = _idx;
            var names$1 = _names;
            if (!names$1) {
              return {
                      TAG: /* Err */1,
                      _0: {
                        TAG: /* Type_error_variable_not_found */0,
                        _0: name
                      }
                    };
            }
            if (Caml_obj.caml_equal(names$1.hd, name)) {
              return {
                      TAG: /* Ok */0,
                      _0: {
                        TAG: /* Ast_var */0,
                        _0: idx
                      }
                    };
            }
            _idx = idx + 1 | 0;
            _names = names$1.tl;
            continue ;
          };
      case /* Term_abs */1 :
          var body = tm._2;
          var name$1 = tm._1;
          return Result$ReasonLambdas.Monad.$great$great$eq(get_structural_ty(tm._0, ty_names), (function (ty) {
                        return Result$ReasonLambdas.Monad.$great$great$eq(finish_rec(body, {
                                        hd: name$1,
                                        tl: names
                                      }, {
                                        hd: ty,
                                        tl: tys
                                      }, ty_names), (function (body$prime) {
                                      return Result$ReasonLambdas.Monad.pure({
                                                  TAG: /* Ast_abs */1,
                                                  _0: ty,
                                                  _1: name$1,
                                                  _2: body$prime
                                                });
                                    }));
                      }));
      case /* Term_app */2 :
          var parm = tm._1;
          return Result$ReasonLambdas.Monad.$great$great$eq(finish_rec(tm._0, names, tys, ty_names), (function (callee$prime) {
                        return Result$ReasonLambdas.Monad.$great$great$eq(finish_rec(parm, names, tys, ty_names), (function (parm$prime) {
                                      return Result$ReasonLambdas.Monad.$great$great$eq(typeof_rec(callee$prime, tys), (function (it) {
                                                    if (typeof it === "number") {
                                                      return {
                                                              TAG: /* Err */1,
                                                              _0: {
                                                                TAG: /* Type_error_calling_non_callable */3,
                                                                _0: it,
                                                                _1: {
                                                                  TAG: /* Ast_app */2,
                                                                  _0: callee$prime,
                                                                  _1: parm$prime
                                                                }
                                                              }
                                                            };
                                                    }
                                                    if (it.TAG) {
                                                      return Pervasives.failwith("substitution of named types failed");
                                                    }
                                                    var parm_ty = it._0;
                                                    return Result$ReasonLambdas.Monad.$great$great$eq(typeof_rec(parm$prime, tys), (function (parm_ty$prime) {
                                                                  if (Caml_obj.caml_notequal(parm_ty, parm_ty$prime)) {
                                                                    return {
                                                                            TAG: /* Err */1,
                                                                            _0: {
                                                                              TAG: /* Type_error_incorrect_types */2,
                                                                              _0: parm_ty,
                                                                              _1: parm_ty$prime
                                                                            }
                                                                          };
                                                                  } else {
                                                                    return {
                                                                            TAG: /* Ok */0,
                                                                            _0: {
                                                                              TAG: /* Ast_app */2,
                                                                              _0: callee$prime,
                                                                              _1: parm$prime
                                                                            }
                                                                          };
                                                                  }
                                                                }));
                                                  }));
                                    }));
                      }));
      case /* Term_let_in */3 :
          var body$1 = tm._2;
          var name$2 = tm._0;
          return Result$ReasonLambdas.Monad.$great$great$eq(finish_rec(tm._1, names, tys, ty_names), (function (init$prime) {
                        var init_ty = $$typeof(init$prime);
                        return Result$ReasonLambdas.Monad.$great$great$eq(finish_rec(body$1, {
                                        hd: name$2,
                                        tl: names
                                      }, {
                                        hd: init_ty,
                                        tl: tys
                                      }, ty_names), (function (body$prime) {
                                      return Result$ReasonLambdas.Monad.pure({
                                                  TAG: /* Ast_app */2,
                                                  _0: {
                                                    TAG: /* Ast_abs */1,
                                                    _0: init_ty,
                                                    _1: name$2,
                                                    _2: body$prime
                                                  },
                                                  _1: init$prime
                                                });
                                    }));
                      }));
      case /* Term_type_in */4 :
          var body$2 = tm._2;
          var name$3 = tm._0;
          return Result$ReasonLambdas.Monad.$great$great$eq(get_structural_ty(tm._1, ty_names), (function (ty) {
                        return finish_rec(body$2, names, tys, {
                                    hd: [
                                      name$3,
                                      ty
                                    ],
                                    tl: ty_names
                                  });
                      }));
      
    }
  };
  return finish_rec(tm, /* [] */0, /* [] */0, /* [] */0);
}

function substitute(body, parm) {
  var sub_rec = function (body, parm, idx) {
    if (typeof body === "number") {
      return body;
    }
    switch (body.TAG | 0) {
      case /* Ast_var */0 :
          if (idx === body._0) {
            return parm;
          } else {
            return body;
          }
      case /* Ast_abs */1 :
          return {
                  TAG: /* Ast_abs */1,
                  _0: body._0,
                  _1: body._1,
                  _2: sub_rec(body._2, parm, idx + 1 | 0)
                };
      case /* Ast_app */2 :
          return {
                  TAG: /* Ast_app */2,
                  _0: sub_rec(body._0, parm, idx),
                  _1: sub_rec(body._1, parm, idx)
                };
      
    }
  };
  return sub_rec(body, parm, 0);
}

function eval1(ast) {
  var eval_app = function (callee, parm) {
    if (typeof callee === "number") {
      if (callee !== /* Ast_marker */0) {
        return ;
      }
      var parm$prime = eval1(parm);
      if (parm$prime !== undefined) {
        return {
                TAG: /* Ast_app */2,
                _0: /* Ast_marker */0,
                _1: parm$prime
              };
      } else {
        return ;
      }
    } else {
      switch (callee.TAG | 0) {
        case /* Ast_var */0 :
            return Pervasives.failwith("malformed lambda ast");
        case /* Ast_abs */1 :
            return substitute(callee._2, parm);
        case /* Ast_app */2 :
            var callee$1 = eval_app(callee._0, callee._1);
            if (callee$1 !== undefined) {
              return {
                      TAG: /* Ast_app */2,
                      _0: callee$1,
                      _1: parm
                    };
            }
            var parm$1 = eval1(parm);
            if (parm$1 !== undefined) {
              return {
                      TAG: /* Ast_app */2,
                      _0: callee,
                      _1: parm$1
                    };
            } else {
              return ;
            }
        
      }
    }
  };
  if (typeof ast === "number") {
    return ;
  }
  switch (ast.TAG | 0) {
    case /* Ast_var */0 :
        return Pervasives.failwith("malformed ast");
    case /* Ast_app */2 :
        return eval_app(ast._0, ast._1);
    default:
      return ;
  }
}

exports.ty_unit = ty_unit;
exports.ty_lam = ty_lam;
exports.ty_named = ty_named;
exports.unit = unit;
exports.marker = marker;
exports.$$var = $$var;
exports.abs = abs;
exports.app = app;
exports.let_in = let_in;
exports.type_in = type_in;
exports.finish = finish;
exports.$$typeof = $$typeof;
exports.eval1 = eval1;
exports.print_ty = print_ty;
exports.print_term = print_term;
exports.print_ast = print_ast;
exports.print_type_error = print_type_error;
/* No side effect */

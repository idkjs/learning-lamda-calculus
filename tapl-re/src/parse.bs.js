// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Lambda$ReasonLambdas = require("./lambda.bs.js");
var Result$ReasonLambdas = require("./result.bs.js");

function string_of_token(tok) {
  if (typeof tok !== "number") {
    return tok._0;
  }
  switch (tok) {
    case /* Tok_lambda */0 :
        return "/";
    case /* Tok_dot */1 :
        return ".";
    case /* Tok_colon */2 :
        return ":";
    case /* Tok_unit */3 :
        return "unit";
    case /* Tok_arrow */4 :
        return "->";
    case /* Tok_open_paren */5 :
        return "(";
    case /* Tok_close_paren */6 :
        return ")";
    case /* Tok_marker */7 :
        return "@";
    case /* Tok_let */8 :
        return "let";
    case /* Tok_type */9 :
        return "type";
    case /* Tok_equals */10 :
        return "=";
    case /* Tok_in */11 :
        return "in";
    case /* Tok_underscore */12 :
        return "_";
    
  }
}

function is_whitespace(ch) {
  if (ch === /* " " */32 || ch === /* "\t" */9 || ch === /* "\n" */10) {
    return true;
  } else {
    return ch === /* "\r" */13;
  }
}

function is_alpha(ch) {
  if (ch >= /* "A" */65 && ch <= /* "Z" */90) {
    return true;
  } else if (ch >= /* "a" */97) {
    return ch <= /* "z" */122;
  } else {
    return false;
  }
}

function is_ident_start(ch) {
  if (is_alpha(ch)) {
    return true;
  } else {
    return ch === /* "_" */95;
  }
}

function is_ident_continue(ch) {
  if (is_ident_start(ch)) {
    return true;
  } else {
    return ch === /* "'" */39;
  }
}

function next_token(lex) {
  var peek_ch = function (param) {
    if (lex.buffer.length <= lex.idx) {
      return ;
    } else {
      return Caml_string.get(lex.buffer, lex.idx);
    }
  };
  var next_ch = function (param) {
    var ch = peek_ch(undefined);
    if (ch !== undefined) {
      lex.idx = lex.idx + 1 | 0;
      return ch;
    }
    
  };
  var eat_whitespace = function (_param) {
    while(true) {
      var ch = peek_ch(undefined);
      if (ch === undefined) {
        return ;
      }
      if (!is_whitespace(ch)) {
        return ;
      }
      next_ch(undefined);
      _param = undefined;
      continue ;
    };
  };
  var lex_ident = function (fst) {
    var helper = function (bytes, _idx) {
      while(true) {
        var idx = _idx;
        var ch = peek_ch(undefined);
        if (ch === undefined) {
          return idx;
        }
        if (!is_ident_continue(ch)) {
          return idx;
        }
        next_ch(undefined);
        if (idx >= bytes.length) {
          return Pervasives.failwith("identifiers longer than " + (String(bytes.length) + " are not supported"));
        }
        bytes[idx] = ch;
        _idx = idx + 1 | 0;
        continue ;
      };
    };
    var bytes = Caml_bytes.caml_create_bytes(16);
    bytes[0] = fst;
    var length = helper(bytes, 1);
    return Bytes.unsafe_to_string(Bytes.extend(bytes, 0, length - bytes.length | 0));
  };
  var peek = lex.peekahead;
  if (peek !== undefined) {
    lex.peekahead = undefined;
    return {
            TAG: /* Ok */0,
            _0: peek
          };
  }
  eat_whitespace(undefined);
  var ch = next_ch(undefined);
  if (ch === undefined) {
    return {
            TAG: /* Err */1,
            _0: /* Lexer_error_end_of_file */0
          };
  }
  switch (ch) {
    case 40 :
        return {
                TAG: /* Ok */0,
                _0: /* Tok_open_paren */5
              };
    case 41 :
        return {
                TAG: /* Ok */0,
                _0: /* Tok_close_paren */6
              };
    case 45 :
        var match = next_ch(undefined);
        if (match === 62) {
          return {
                  TAG: /* Ok */0,
                  _0: /* Tok_arrow */4
                };
        } else {
          return {
                  TAG: /* Err */1,
                  _0: /* Lexer_error_unrecognized_character */{
                    _0: /* "-" */45
                  }
                };
        }
    case 46 :
        return {
                TAG: /* Ok */0,
                _0: /* Tok_dot */1
              };
    case 47 :
        return {
                TAG: /* Ok */0,
                _0: /* Tok_lambda */0
              };
    case 58 :
        return {
                TAG: /* Ok */0,
                _0: /* Tok_colon */2
              };
    case 61 :
        return {
                TAG: /* Ok */0,
                _0: /* Tok_equals */10
              };
    case 42 :
    case 43 :
    case 44 :
    case 48 :
    case 49 :
    case 50 :
    case 51 :
    case 52 :
    case 53 :
    case 54 :
    case 55 :
    case 56 :
    case 57 :
    case 59 :
    case 60 :
    case 62 :
    case 63 :
        break;
    case 64 :
        return {
                TAG: /* Ok */0,
                _0: /* Tok_marker */7
              };
    default:
      
  }
  if (!is_ident_start(ch)) {
    return {
            TAG: /* Err */1,
            _0: /* Lexer_error_unrecognized_character */{
              _0: ch
            }
          };
  }
  var res = lex_ident(ch);
  if (res === "unit") {
    return {
            TAG: /* Ok */0,
            _0: /* Tok_unit */3
          };
  } else if (res === "_") {
    return {
            TAG: /* Ok */0,
            _0: /* Tok_underscore */12
          };
  } else if (res === "let") {
    return {
            TAG: /* Ok */0,
            _0: /* Tok_let */8
          };
  } else if (res === "type") {
    return {
            TAG: /* Ok */0,
            _0: /* Tok_type */9
          };
  } else if (res === "in") {
    return {
            TAG: /* Ok */0,
            _0: /* Tok_in */11
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: /* Tok_var */{
              _0: res
            }
          };
  }
}

function peek_token(lex) {
  return Result$ReasonLambdas.Monad.$great$great$eq(next_token(lex), (function (tok) {
                lex.peekahead = tok;
                return Result$ReasonLambdas.Monad.pure(tok);
              }));
}

function print_parser_error(err) {
  if (typeof err === "number") {
    return Pervasives.print_string("unexpected end of file");
  }
  if (err.TAG) {
    return Pervasives.print_string("unexpected token: " + string_of_token(err._0));
  }
  var ch = err._0;
  return Curry._2(Printf.printf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "unrecognized character: ",
                    _1: {
                      TAG: /* Char */0,
                      _0: {
                        TAG: /* String_literal */11,
                        _0: " (",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* ")" */41,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "unrecognized character: %c (%d)"
                }), ch, ch);
}

function maybe_parse_term(lex) {
  var final_case = function (r) {
    if (!r.TAG) {
      return {
              TAG: /* Err */1,
              _0: {
                TAG: /* Parser_error_unexpected_token */1,
                _0: r._0
              }
            };
    }
    var ch = r._0;
    if (ch) {
      return {
              TAG: /* Err */1,
              _0: {
                TAG: /* Parser_error_unrecognized_character */0,
                _0: ch._0
              }
            };
    } else {
      return {
              TAG: /* Err */1,
              _0: /* Parser_error_unexpected_eof */0
            };
    }
  };
  var get_var_or_under = function (param) {
    var r = next_token(lex);
    if (r.TAG) {
      return final_case(r);
    }
    var name = r._0;
    if (typeof name === "number") {
      if (name >= 12) {
        return {
                TAG: /* Ok */0,
                _0: undefined
              };
      } else {
        return final_case(r);
      }
    } else {
      return {
              TAG: /* Ok */0,
              _0: name._0
            };
    }
  };
  var get_var = function (param) {
    return Result$ReasonLambdas.Monad.$great$great$eq(get_var_or_under(undefined), (function (name) {
                  if (name !== undefined) {
                    return {
                            TAG: /* Ok */0,
                            _0: name
                          };
                  } else {
                    return {
                            TAG: /* Err */1,
                            _0: {
                              TAG: /* Parser_error_unexpected_token */1,
                              _0: /* Tok_underscore */12
                            }
                          };
                  }
                }));
  };
  var get_dot = function (param) {
    var r = next_token(lex);
    if (r.TAG) {
      return final_case(r);
    }
    var match = r._0;
    if (typeof match === "number" && match === 1) {
      return {
              TAG: /* Ok */0,
              _0: undefined
            };
    } else {
      return final_case(r);
    }
  };
  var get_colon = function (param) {
    var r = next_token(lex);
    if (r.TAG) {
      return final_case(r);
    }
    var match = r._0;
    if (typeof match === "number" && match === 2) {
      return {
              TAG: /* Ok */0,
              _0: undefined
            };
    } else {
      return final_case(r);
    }
  };
  var get_close_paren = function (param) {
    var r = next_token(lex);
    if (r.TAG) {
      return final_case(r);
    }
    var match = r._0;
    if (typeof match === "number" && match === 6) {
      return {
              TAG: /* Ok */0,
              _0: undefined
            };
    } else {
      return final_case(r);
    }
  };
  var get_equals = function (param) {
    var r = next_token(lex);
    if (r.TAG) {
      return final_case(r);
    }
    var match = r._0;
    if (typeof match === "number" && match === 10) {
      return {
              TAG: /* Ok */0,
              _0: undefined
            };
    } else {
      return final_case(r);
    }
  };
  var get_in = function (param) {
    var r = next_token(lex);
    if (r.TAG) {
      return final_case(r);
    }
    var match = r._0;
    if (typeof match === "number" && match === 11) {
      return {
              TAG: /* Ok */0,
              _0: undefined
            };
    } else {
      return final_case(r);
    }
  };
  var get_ty = function (param) {
    var r = next_token(lex);
    var lhs;
    if (r.TAG) {
      lhs = final_case(r);
    } else {
      var name = r._0;
      if (typeof name === "number") {
        switch (name) {
          case /* Tok_unit */3 :
              lhs = {
                TAG: /* Ok */0,
                _0: Lambda$ReasonLambdas.ty_unit(undefined)
              };
              break;
          case /* Tok_arrow */4 :
              lhs = final_case(r);
              break;
          case /* Tok_open_paren */5 :
              lhs = Result$ReasonLambdas.Monad.$great$great$eq(get_ty(undefined), (function (ty) {
                      return Result$ReasonLambdas.Monad.$great$great$eq(get_close_paren(undefined), (function (param) {
                                    return Result$ReasonLambdas.Monad.pure(ty);
                                  }));
                    }));
              break;
          default:
            lhs = final_case(r);
        }
      } else {
        lhs = {
          TAG: /* Ok */0,
          _0: Lambda$ReasonLambdas.ty_named(name._0)
        };
      }
    }
    return Result$ReasonLambdas.Monad.$great$great$eq(lhs, (function (lhs) {
                  var match = peek_token(lex);
                  if (match.TAG) {
                    var ch = match._0;
                    if (ch) {
                      return {
                              TAG: /* Err */1,
                              _0: {
                                TAG: /* Parser_error_unrecognized_character */0,
                                _0: ch._0
                              }
                            };
                    } else {
                      return {
                              TAG: /* Ok */0,
                              _0: lhs
                            };
                    }
                  }
                  var match$1 = match._0;
                  if (typeof match$1 === "number" && match$1 === 4) {
                    next_token(lex);
                    return Result$ReasonLambdas.Monad.$great$great$eq(get_ty(undefined), (function (it) {
                                  return Result$ReasonLambdas.Monad.pure(Lambda$ReasonLambdas.ty_lam(lhs, it));
                                }));
                  } else {
                    return {
                            TAG: /* Ok */0,
                            _0: lhs
                          };
                  }
                }));
  };
  var parse_app_list = function (_fst) {
    while(true) {
      var fst = _fst;
      var tok = peek_token(lex);
      if (tok.TAG) {
        var ch = tok._0;
        if (ch) {
          return {
                  TAG: /* Err */1,
                  _0: {
                    TAG: /* Parser_error_unrecognized_character */0,
                    _0: ch._0
                  }
                };
        } else {
          return {
                  TAG: /* Ok */0,
                  _0: fst
                };
        }
      }
      var snd = tok._0;
      if (typeof snd === "number") {
        switch (snd) {
          case /* Tok_lambda */0 :
              return Result$ReasonLambdas.Monad.$great$great$eq(parse_term(lex), (function(fst){
                        return function (it) {
                          return Result$ReasonLambdas.Monad.pure(Lambda$ReasonLambdas.app(fst, it));
                        }
                        }(fst)));
          case /* Tok_open_paren */5 :
              next_token(lex);
              var r = peek_token(lex);
              var snd$1;
              if (r.TAG) {
                snd$1 = final_case(r);
              } else {
                var match = r._0;
                snd$1 = typeof match === "number" && match === 6 ? ({
                      TAG: /* Ok */0,
                      _0: Lambda$ReasonLambdas.unit(undefined)
                    }) : parse_term(lex);
              }
              return Result$ReasonLambdas.Monad.$great$great$eq(snd$1, (function(fst){
                        return function (snd) {
                          return Result$ReasonLambdas.Monad.$great$great$eq(get_close_paren(undefined), (function (param) {
                                        return parse_app_list(Lambda$ReasonLambdas.app(fst, snd));
                                      }));
                        }
                        }(fst)));
          case /* Tok_marker */7 :
              next_token(lex);
              _fst = Lambda$ReasonLambdas.app(fst, Lambda$ReasonLambdas.marker(undefined));
              continue ;
          case /* Tok_close_paren */6 :
          case /* Tok_in */11 :
              return {
                      TAG: /* Ok */0,
                      _0: fst
                    };
          case /* Tok_dot */1 :
          case /* Tok_colon */2 :
          case /* Tok_unit */3 :
          case /* Tok_arrow */4 :
          case /* Tok_let */8 :
          case /* Tok_type */9 :
          case /* Tok_equals */10 :
          case /* Tok_underscore */12 :
              return {
                      TAG: /* Err */1,
                      _0: {
                        TAG: /* Parser_error_unexpected_token */1,
                        _0: snd
                      }
                    };
          
        }
      } else {
        next_token(lex);
        _fst = Lambda$ReasonLambdas.app(fst, Lambda$ReasonLambdas.$$var(snd._0));
        continue ;
      }
    };
  };
  var tok = peek_token(lex);
  if (tok.TAG) {
    var ch = tok._0;
    if (ch) {
      return {
              TAG: /* Err */1,
              _0: {
                TAG: /* Parser_error_unrecognized_character */0,
                _0: ch._0
              }
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: undefined
            };
    }
  }
  var name = tok._0;
  if (typeof name === "number") {
    switch (name) {
      case /* Tok_lambda */0 :
          next_token(lex);
          return Result$ReasonLambdas.Monad.$great$great$eq(get_var_or_under(undefined), (function (name) {
                        return Result$ReasonLambdas.Monad.$great$great$eq(get_colon(undefined), (function (param) {
                                      return Result$ReasonLambdas.Monad.$great$great$eq(get_ty(undefined), (function (ty) {
                                                    return Result$ReasonLambdas.Monad.$great$great$eq(get_dot(undefined), (function (param) {
                                                                  return Result$ReasonLambdas.Monad.$great$great$eq(parse_term(lex), (function (body) {
                                                                                return Result$ReasonLambdas.Monad.pure(Caml_option.some(Lambda$ReasonLambdas.abs(ty, name, body)));
                                                                              }));
                                                                }));
                                                  }));
                                    }));
                      }));
      case /* Tok_open_paren */5 :
          next_token(lex);
          var r = peek_token(lex);
          if (r.TAG) {
            return final_case(r);
          }
          var match = r._0;
          if (typeof match === "number" && match === 6) {
            next_token(lex);
            return Result$ReasonLambdas.Monad.$great$great$eq(parse_app_list(Lambda$ReasonLambdas.unit(undefined)), (function (it) {
                          return Result$ReasonLambdas.Monad.pure(Caml_option.some(it));
                        }));
          }
          return Result$ReasonLambdas.Monad.$great$great$eq(parse_term(lex), (function (ret) {
                        return Result$ReasonLambdas.Monad.$great$great$eq(get_close_paren(undefined), (function (param) {
                                      return Result$ReasonLambdas.Monad.$great$great$eq(parse_app_list(ret), (function (it) {
                                                    return Result$ReasonLambdas.Monad.pure(Caml_option.some(it));
                                                  }));
                                    }));
                      }));
          break;
      case /* Tok_close_paren */6 :
          return {
                  TAG: /* Ok */0,
                  _0: undefined
                };
      case /* Tok_marker */7 :
          next_token(lex);
          return Result$ReasonLambdas.Monad.$great$great$eq(parse_app_list(Lambda$ReasonLambdas.marker(undefined)), (function (it) {
                        return Result$ReasonLambdas.Monad.pure(Caml_option.some(it));
                      }));
      case /* Tok_let */8 :
          next_token(lex);
          return Result$ReasonLambdas.Monad.$great$great$eq(get_var(undefined), (function (name) {
                        return Result$ReasonLambdas.Monad.$great$great$eq(get_equals(undefined), (function (param) {
                                      return Result$ReasonLambdas.Monad.$great$great$eq(parse_term(lex), (function (init) {
                                                    return Result$ReasonLambdas.Monad.$great$great$eq(get_in(undefined), (function (param) {
                                                                  return Result$ReasonLambdas.Monad.$great$great$eq(parse_term(lex), (function (body) {
                                                                                return Result$ReasonLambdas.Monad.pure(Caml_option.some(Lambda$ReasonLambdas.let_in(name, init, body)));
                                                                              }));
                                                                }));
                                                  }));
                                    }));
                      }));
      case /* Tok_type */9 :
          next_token(lex);
          return Result$ReasonLambdas.Monad.$great$great$eq(get_var(undefined), (function (name) {
                        return Result$ReasonLambdas.Monad.$great$great$eq(get_equals(undefined), (function (param) {
                                      return Result$ReasonLambdas.Monad.$great$great$eq(get_ty(undefined), (function (ty) {
                                                    return Result$ReasonLambdas.Monad.$great$great$eq(get_in(undefined), (function (param) {
                                                                  return Result$ReasonLambdas.Monad.$great$great$eq(parse_term(lex), (function (body) {
                                                                                return Result$ReasonLambdas.Monad.pure(Caml_option.some(Lambda$ReasonLambdas.type_in(name, ty, body)));
                                                                              }));
                                                                }));
                                                  }));
                                    }));
                      }));
      case /* Tok_dot */1 :
      case /* Tok_colon */2 :
      case /* Tok_unit */3 :
      case /* Tok_arrow */4 :
      case /* Tok_equals */10 :
      case /* Tok_in */11 :
      case /* Tok_underscore */12 :
          return {
                  TAG: /* Err */1,
                  _0: {
                    TAG: /* Parser_error_unexpected_token */1,
                    _0: name
                  }
                };
      
    }
  } else {
    next_token(lex);
    return Result$ReasonLambdas.Monad.$great$great$eq(parse_app_list(Lambda$ReasonLambdas.$$var(name._0)), (function (it) {
                  return Result$ReasonLambdas.Monad.pure(Caml_option.some(it));
                }));
  }
}

function parse_term(lex) {
  return Result$ReasonLambdas.Monad.$great$great$eq(maybe_parse_term(lex), (function (tm) {
                if (tm !== undefined) {
                  return {
                          TAG: /* Ok */0,
                          _0: Caml_option.valFromOption(tm)
                        };
                }
                var tok = next_token(lex);
                if (!tok.TAG) {
                  return {
                          TAG: /* Err */1,
                          _0: {
                            TAG: /* Parser_error_unexpected_token */1,
                            _0: tok._0
                          }
                        };
                }
                var ch = tok._0;
                if (ch) {
                  return {
                          TAG: /* Err */1,
                          _0: {
                            TAG: /* Parser_error_unrecognized_character */0,
                            _0: ch._0
                          }
                        };
                } else {
                  return {
                          TAG: /* Err */1,
                          _0: /* Parser_error_unexpected_eof */0
                        };
                }
              }));
}

function parse(buff) {
  var rest = function (lex) {
    var len = lex.buffer.length - lex.idx | 0;
    return $$String.sub(lex.buffer, lex.idx, len);
  };
  var lex = {
    buffer: buff,
    idx: 0,
    peekahead: undefined
  };
  return Result$ReasonLambdas.Monad.$great$great$eq(parse_term(lex), (function (ret) {
                var match = next_token(lex);
                if (match.TAG) {
                  if (match._0) {
                    Pervasives.failwith("parser didn't eat all the input: " + rest(lex));
                  }
                  
                } else {
                  Pervasives.failwith("parser didn't eat all the input: " + rest(lex));
                }
                return {
                        TAG: /* Ok */0,
                        _0: ret
                      };
              }));
}

exports.print_parser_error = print_parser_error;
exports.parse = parse;
/* No side effect */
